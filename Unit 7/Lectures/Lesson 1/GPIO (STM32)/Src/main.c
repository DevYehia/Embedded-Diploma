/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//bitwise macros
#define SET_BIT(reg,bit) (reg |= (1 << (bit)))
#define CLR_BIT(reg,bit) (reg &= ~(1 << (bit)))
#define GET_BIT(reg,bit) ((reg >> (bit)) & 1)
#define TGL_BIT(reg,bit) (reg ^= (1 << (bit)))

#define RCC_BASE 0x40021000
#define RCC_APB2EN *(volatile unsigned int *)(RCC_BASE + 0x18)
#define IOPAEN_PIN 2
#define IOPBEN_PIN 3

#define GPIOA_BASE 0x40010800
#define GPIOA_CRL *(volatile unsigned int *)(GPIOA_BASE + 0x00)
#define GPIOA_CRH *(volatile unsigned int *)(GPIOA_BASE + 0x04)
#define GPIOA_IDR *(volatile unsigned int *)(GPIOA_BASE + 0x08)
#define GPIOA_ODR *(volatile unsigned int *)(GPIOA_BASE + 0x0C)

#define GPIOB_BASE 0x40010C00
#define GPIOB_CRL *(volatile unsigned int *)(GPIOB_BASE + 0x00)
#define GPIOB_CRH *(volatile unsigned int *)(GPIOB_BASE + 0x04)
#define GPIOB_IDR *(volatile unsigned int *)(GPIOB_BASE + 0x08)
#define GPIOB_ODR *(volatile unsigned int *)(GPIOB_BASE + 0x0C)

#define GET_CR_LSB(pin) (((pin < 8) ? pin * 4 : (pin - 8) * 4))

void GPIO_init(void){
  
  //enable clock to GPIO A and GPIO B
  SET_BIT(RCC_APB2EN, IOPAEN_PIN);
  SET_BIT(RCC_APB2EN, IOPBEN_PIN);

  //Pins configuration
  //A1 --> Floating Input
  //A13 --> Floating Input
  //B1 --> (Push-Pull) Output
  //B13 --> (Push-Pull) Output

  //A1 Configuration (0100)
  int pin1_LSB = GET_CR_LSB(1); //LSB of pin A1 in CRL
  CLR_BIT(GPIOA_CRL,pin1_LSB);
  CLR_BIT(GPIOA_CRL,pin1_LSB + 1);
  SET_BIT(GPIOA_CRL,pin1_LSB + 2);
  CLR_BIT(GPIOA_CRL,pin1_LSB + 3);  

  //A13 Configuration (0100)
  int pin13_LSB = GET_CR_LSB(13); //LSB of pin A13 in CRH
  CLR_BIT(GPIOA_CRH,pin13_LSB);
  CLR_BIT(GPIOA_CRH,pin13_LSB + 1);
  SET_BIT(GPIOA_CRH,pin13_LSB + 2);
  CLR_BIT(GPIOA_CRH,pin13_LSB + 3);  

  //B1 Configuration (0001)
  SET_BIT(GPIOB_CRL,pin1_LSB);
  CLR_BIT(GPIOB_CRL,pin1_LSB + 1);
  CLR_BIT(GPIOB_CRL,pin1_LSB + 2);
  CLR_BIT(GPIOB_CRL,pin1_LSB + 3);  

  //B13 Configuration (0001)
  SET_BIT(GPIOB_CRH,pin13_LSB);
  CLR_BIT(GPIOB_CRH,pin13_LSB + 1);
  CLR_BIT(GPIOB_CRH,pin13_LSB + 2);
  CLR_BIT(GPIOB_CRH,pin13_LSB + 3);  

}

void delay(int time){
  for(int i = 0 ; i < time ; i++){
    for(int j = 0 ; j < 255 ; j++);
  }
}

int main(void)
{
  GPIO_init();
    /* Loop forever */
	for(;;){
    if(GET_BIT(GPIOA_IDR,1) == 0){ //single press
      TGL_BIT(GPIOB_ODR, 1);
      while(GET_BIT(GPIOA_IDR,1) == 0);
    }
    if(GET_BIT(GPIOA_IDR,13) == 1){ //multiple press
      TGL_BIT(GPIOB_ODR, 13);
    }
    delay(1000);
  }

}
